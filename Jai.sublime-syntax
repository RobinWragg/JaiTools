%YAML 1.2
---

# Official syntax tutorial: http://www.sublimetext.com/docs/3/syntax.html
# Official scope names: https://www.sublimetext.com/docs/3/scope_naming.html

# TODO: Arrays
# TODO: Parameterized types
# TODO: namespacing and other visibility-based features

# Builtin storage types for reference (not used directly by this file):
# Any void string bool float float32 float64 int u8 u16 u32 u64 s8 s16 s32 s64
# Unlike the C++ syntax, we recognise type names based on their context in code, which means we can appropriately highlight user-defined types (structs)

name: Jai
file_extensions:
  - jai

scope: source.jai

variables:
  # Variable names must by a-z only!
  type_name: '\b\w+?\b'
  var_or_func_name: '\b[a-zA-Z_]\w*?\b'
  herestring_delimiter: '[\w\W]+'

contexts:
  main:
    - include: common
    - match: '{'
      push: block
  
  block:
    - include: common
    - meta_scope: meta.block.jai
    - match: '{'
      push: block
    - match: '}'
      pop: true

  common:
    - include: escapes
    - include: keyword
    - match: ','
      scope: punctuation.separator.jai
    - include: check_for_function_definition
    - match: '\b\w+(?=\s*:\s*[:=]\s*struct)'
      scope: entity.name.struct.jai
      push: struct_definition
    - match: '\b\w+(?=\s*:\s*[:=]\s*enum)'
      scope: entity.name.enum.jai
      push: enum_definition
    - include: check_for_variable_definition
    - include: expression
    - match: ';'
      scope: punctuation.terminator.jai
  
  escapes:
    - include: comment

    # Herestring literals.
    # NOTE: Must have priority over general preprocessor rule
    - match: '#string\s+({{herestring_delimiter}})(?=\s)'
      captures:
        1: constant.other.stringdelimiter.jai
      scope: meta.preprocessor.jai
      embed: herestring_content
      escape: ^(\1)$
      escape_captures:
        1: constant.other.stringdelimiter.jai
    
    # Preprocessor-style directives (#run, #must, etc)
    - match: '#import\s*'
      scope: keyword.control.import.jai
    - match: '#(?:\w+\b)?'
      scope: meta.preprocessor.jai
    
    # Tags
    - match: '(@)(?:\w+\b)?'
      captures:
        1: punctuation.definition.annotation.jai
      scope: meta.annotation.jai
  
  herestring_content:
    - meta_scope: string.unquoted.jai

  string_literal:
    - meta_scope: string.quoted.double.jai
    - match: '\\.'
      scope: constant.character.escape.jai
    - match: '%'
      scope: constant.other.placeholder.jai
    - match: '"'
      pop: true
    
  multiline_comment:
    - match: /\*
      push:
        - include: multiline_comment
        - meta_scope: comment.block.jai
        - match: \*/
          pop: true
  
  comment:
    - include: multiline_comment
    - match: //
      push:
        - meta_scope: comment.line.jai
        - match: $
          pop: true
  
  keyword:
    - match: '>>|<<|[~&|]'
      scope: keyword.operator.bitwise.jai
    - match: '[><!]|=='
      scope: keyword.operator.logical.jai
    - match: '[+*/-]'
      scope: keyword.operator.arithmetic.jai
    - match: '='
      scope: keyword.operator.assignment.jai
    - match: '\b(?:struct|using)\b'
      scope: keyword.other.jai
    - match: '\b(?:return|if|then|else|for|while|break|continue)\b'
      scope: keyword.control.jai
  
  expression:
    - include: escapes
    - include: keyword
    - match: '\b(?:it|it_index)\b'
      scope: variable.language.jai
    - match: '"'
      push: string_literal
    - match: '\b(?:null|true|false)\b'
      scope: constant.language.jai
    - match: '{{var_or_func_name}}(?=\()'
      scope: variable.function.jai
    - match: '{{var_or_func_name}}'
      scope: variable.other.jai
    - match: '\b0h[a-fA-F0-9]+'
      scope: constant.numeric.float.hexadecimal.jai
    - match: '\b0x[a-fA-F0-9]+'
      scope: constant.numeric.integer.hexadecimal.jai
    - match: '\b\d+\.\d*'
      scope: constant.numeric.float.decimal.jai
    - match: '\b\d+'
      scope: constant.numeric.integer.decimal.jai
    - match: '(?<=\w)(\.)({{var_or_func_name}})'
      captures:
        1: punctuation.accessor.jai
        2: variable.other.member.jai
    - match: '\['
      scope: punctuation.section.brackets.begin.jai
    - match: '\]'
      scope: punctuation.section.brackets.end.jai
  
  check_for_function_definition:
    # Function definition with line ending before )
    - match: '\b\w+(?=\s*:\s*[:=]\s*\(\s*\w+:)'
      scope: entity.name.function.jai
      push: function_definition
    # Function definition with line ending immediately after (
    - match: '\b\w+(?=\s*:\s*[:=]\s*\(\s*(?:$|\/))'
      scope: entity.name.function.jai
      push: function_definition
    # Full, one-line function definition
    - match: '\b\w+(?=\s*:\s*[:=]\s*\([^)]*?\)\s*(?:{|->))'
      scope: entity.name.function.jai
      push: function_definition
    
  function_definition:
    - meta_scope: meta.function.jai
    - include: escapes
    - match: '::|:='
      scope: keyword.operator.assignment.jai
    - match: '\('
      push: function_parameters
    - match: '\s*->\s*'
      scope: keyword.other.jai
      push: function_return_specifier
    - match: '(?=\s*[{;])'
      pop: true
  
  function_parameters:
    - meta_content_scope: meta.function.parameters.jai
    - include: escapes
    - match: '({{var_or_func_name}})\s*(:)\s*'
      captures:
        1: variable.parameter.jai
        2: keyword.operator.assignment.jai
      push: function_parameter_type
    - match: ','
      scope: punctuation.separator.jai
    - match: '\)'
      pop: true
  
  function_return_specifier:
    - include: escapes
    - match: '\s*({{var_or_func_name}})\s*(:)\s*({{type_name}})\s*'
      captures:
        1: variable.return-value.jai
        2: keyword.operator.assignment.jai
        3: storage.type.jai
    - match: ','
      scope: punctuation.separator.jai
    - match: '\s*{{type_name}}\s*(?={|;|,|(?:/.*)?$)'
      scope: storage.type.jai
    - match: '(?=\s*[{;])'
      pop: true
  
  function_parameter_type:
    - include: escapes
    - match: '\s*{{type_name}}\s*'
      scope: storage.type.jai
    - match: '(?=,)'
      pop: true
    - match: '(?=\))'
      pop: true

  struct_definition:
    - meta_scope: meta.struct.jai
    - include: escapes
    - match: '::|:='
      scope: keyword.operator.assignment.jai
    - match: '\bstruct\b'
      scope: keyword.other.jai
    - match: '(?=\s*{)'
      pop: true
  
  enum_definition:
    - meta_scope: meta.enum.jai
    - include: escapes
    - match: '::|:='
      scope: keyword.operator.assignment.jai
    - match: '\benum\b'
      scope: keyword.other.jai
    - match: '(?=\s*{)'
      pop: true
  
  check_for_variable_definition:
    - match: '({{var_or_func_name}})\s*(:)\s*({{type_name}})?\s*(?:(:|=)|(?=;))'
      captures:
        1: entity.name.variable.jai
        2: keyword.operator.assignment.jai
        3: storage.type.jai
        4: keyword.operator.assignment.jai
      push: expression_then_semicolon
  
  expression_then_semicolon:
    - meta_scope: meta.variable.jai
    - include: expression
    - match: ';'
      scope: punctuation.terminator.jai
      pop: true





